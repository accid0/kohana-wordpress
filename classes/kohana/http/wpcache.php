<?php  defined('SYSPATH') or die('No direct script access.');
/**
 * Created by JetBrains PhpStorm.
 * User : Andrew Scherbakov
 * Date : 24.10.12
 * Time : 11:37
 * File : wpcache.php
 * @name Kohana_HTTP_WPCache
 * @packages Wordpress/ThemeFramework/Kohana_HTTP_WPCache
 * @subpackage
 * @category
 * @author Andrew Scherbakov
 * @version 0.1
 * @copyright Â®Â©Andrew Scherbakov
 * To change this template use File | Settings | File Templates.
 */
class Kohana_HTTP_WPCache extends HTTP_Cache
{

  /**
   * Factory method for HTTP_Cache that provides a convenient dependency
   * injector for the Cache library.
   *
   *      // Create HTTP_Cache with named cache engine
   *      $http_cache = HTTP_Cache::factory('memcache', array(
   *          'allow_private_cache' => FALSE
   *          )
   *      );
   *
   *      // Create HTTP_Cache with supplied cache engine
   *      $http_cache = HTTP_Cache::factory(Cache::instance('memcache'),
   *          array(
   *              'allow_private_cache' => FALSE
   *          )
   *      );
   *
   * @uses    [Cache]
   * @param   mixed    cache engine to use
   * @param   array    options to set to this class
   * @return  HTTP_Cache
   */
  public static function factory($cache, array $options = array())
  {
    if ( ! $cache instanceof Cache)
    {
      $cache = Cache::instance($cache);
    }

    $options['cache'] = $cache;

    return new self($options);
  }

  /**
   * Constructor method for this class. Allows dependency injection of the
   * required components such as `Cache` and the cache key generator.
   *
   * @param   array $options
   */
	public function __construct(array $options = array()){
    $options['cache_key_callback'] = array( $this, 'cache_key_generator');
    $options['allow_private_cache'] = TRUE;
    parent::__construct( $options);
  }

  public function cache_key_generator( Request $request ){

    $uri     = $request->uri();
    $query   = $request->query();
    $params  = $request->param();
    $headers = $request->headers()->getArrayCopy();
    unset($headers['if-modified-since']);
    $body    = $request->body();
    $key = $uri.'?'.http_build_query(Arr::merge( $query, $params), NULL, '&').'~'.implode( '~', $headers).'~'.$body;

    return sha1($key);
  }

  /**
   * Executes the supplied [Request] with the supplied [Request_Client].
   * Before execution, the HTTP_Cache adapter checks the request type,
   * destructive requests such as `POST`, `PUT` and `DELETE` will bypass
   * cache completely and ensure the response is not cached. All other
   * Request methods will allow caching, if the rules are met.
   *
   * @param   Request_Client  client to execute with Cache-Control
   * @param   Request   request to execute with client
   * @return  [Response]
   */
  public function execute(Request_Client $client, Request $request)
  {
    if ( ! $this->_cache instanceof Cache)
      return $client->execute_request($request);

    // If this is a destructive request, by-pass cache completely
    if (in_array($request->method(), array(
      HTTP_Request::POST,
      HTTP_Request::PUT,
      HTTP_Request::DELETE)))
    {
      // Kill existing caches for this request
      $this->invalidate_cache($request);

      $response = $client->execute_request($request);

      $cache_control = HTTP_Header::create_cache_control(array(
        'no-cache',
        'must-revalidate'
      ));

      // Ensure client respects destructive action
      return $response->headers('cache-control', $cache_control);
    }

    // Create the cache key
    $cache_key = $this->create_cache_key($request, $this->_cache_key_callback);

    // Try and return cached version
    if ( $response = $this->cache_response($cache_key, $request) ){

      return $response;
    }

    // Start request time
    $this->_request_time = time();

    // Execute the request with the Request client
    $response = $client->execute_request($request);

    // Stop response time
    $this->_response_time = time();

    // Cache the response
    $this->cache_response($cache_key, $request, $response);


    $response->headers(HTTP_Cache::CACHE_STATUS_KEY,
      HTTP_Cache::CACHE_STATUS_MISS);

    return $response;
  }

  /**
   * Caches a [Response] using the supplied [Cache]
   * and the key generated by [Request_Client::_create_cache_key].
   *
   * If not response is supplied, the cache will be checked for an existing
   * one that is available.
   *
   * @param   string    the cache key to use
   * @param   Request   the HTTP Request
   * @param   Response  the HTTP Response
   * @return  mixed
   */
  public function cache_response($key, Request $request, Response $response = NULL)
  {
    if ( ! $this->_cache instanceof Cache)
      return FALSE;

    // Check for Pragma: no-cache
    if ($pragma = $request->headers('pragma'))
    {
      if ($pragma  == 'no-cache')
        return FALSE;
      elseif (is_array($pragma) AND in_array('no-cache', $pragma))
        return FALSE;
    }

    // If there is no response, lookup an existing cached response
    if ($response === NULL)
    {
      $response = $this->_cache->get($key);

      if ( empty($response))
        return FALSE;

      // Do cache hit arithmetic, using fast arithmetic if available
      if ($this->_cache instanceof Cache_Arithmetic)
      {
        $hit_count = $this->_cache->increment(HTTP_Cache::CACHE_HIT_KEY.$key);
      }
      else
      {
        $hit_count = $this->_cache->get(HTTP_Cache::CACHE_HIT_KEY.$key);
        $this->_cache->set(HTTP_Cache::CACHE_HIT_KEY.$key, ++$hit_count);
      }

      // Update the header to have correct HIT status and count
      $response = Response::factory( array( '_body' => $response ));
      $response->headers(HTTP_Cache::CACHE_STATUS_KEY,
        HTTP_Cache::CACHE_STATUS_HIT)
        ->headers(HTTP_Cache::CACHE_HIT_KEY, $hit_count);

      return $response;
    }
    else
    {
      if (($ttl = $this->cache_lifetime($response)) === FALSE)
        return FALSE;
      $response->headers(HTTP_Cache::CACHE_STATUS_KEY,
        HTTP_Cache::CACHE_STATUS_SAVED);

      // Set the hit count to zero
      $this->_cache->set(HTTP_Cache::CACHE_HIT_KEY.$key, 0);

      return $this->_cache->set($key, $response, $ttl);
    }
  }

}
